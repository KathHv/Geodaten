<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>D3 Abgabe 3</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>

    <style>

        .bubble {
            fill: black;
            fill-opacity: .5;
            stroke: #fff;
            stroke-width: 1px;
        }

        .country {
            stroke: black;
            stroke-width: 1px;
        }

            .country.hovered {
                fill: grey;
            }

        .dot {
            fill: #4cff00;
            stroke: #fff;
        }


        #infodiv {
            /*first three attributes: position of the div*/
            position: absolute;
            top: 350px;
            left: 480px;
            /*Next two attributes: dimensions of the div*/
            width: 130px;
            height: 40px;
            border-radius: 10px; /*rounding of the div*/
            background: black; /*bakground color of the div*/
            color: aliceblue; /*color of the text*/
            text-align: center; /*centering the text*/
            display: none; /*hide the div by default*/
        }
    </style>


</head>

<body>


    <script type="text/javascript">

        //Map of Muenster
        //Shapefile from https://milchkuehe.carto.com/tables/shapefile_m_nster_stadtteile/public#/more
        //Converted to topojson here https://mapshaper.org/




        // Map of countries in the world

        // shapefiles were taken from https://www.naturalearthdata.com/downloads/
        // the conversion to topjson was done using https://mapshaper.org/

        // svg margin parameters
        var margin = { top: 20, right: 20, bottom: 20, left: 20 };
        var width = 800 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        var width2 = 500 - margin.left - margin.right,
            height2 = 400 - margin.top - margin.bottom;


        // svg parameters
        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .style("background", "#ececec")
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // parameters of the svg for the line chart
        var svg2 = d3.select("body").append("svg")
            .attr("width", width2 + margin.left + margin.right)
            .attr("height", height2 + margin.top + margin.bottom)
            .style("background", "white")
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // div for the information
        var div = d3.select("body").append("div")
            .attr("id", "infodiv");

        // current projection
        var currentprojection = d3.geoMercator()
            .center([7.6, 51.965])
            .scale(60000)
            .translate([width / 2, height / 2]);

        // geopath
        var geopath = d3.geoPath().projection(currentprojection);

        // format number for human consumption
        var formatNumber = d3.format(",.0f");

        // Labels of the legend are the same as the domain of the color scale
        var legend_labels = color.domain().reverse(); // reverse is optional

        var legend = d3.select("body")
            .append("svg")
            .attr("width", 150)
            .attr("height", 140)
            .style("background", "#d6cbd3")
            .attr("class", "legend")
            .selectAll("g") // one group per label
            .data(legend_labels)
            .enter().append("g")
            .attr("transform", function (d, i) { return "translate(0," + i * 20 + ")"; });

        // create rectangles, one with the color
        legend.append("rect")
            .attr("width", 18)
            .attr("height", 18)
            .style("fill", color);

        // add text, next to the rectangle about what the colors mean
        legend.append("text")
            .attr("x", 24)
            .attr("y", 9)
            .attr("dy", ".35em")
            .text(function (d) { return d; });

        d3.json("https://raw.githubusercontent.com/aurioldegbelo/Geovis2018/master/world_countries2.json  ")
        //d3.json("https://raw.githubusercontent.com/KathHv/Geodaten/master/shapefile_m_nster_stadtteile.json")
            .then(
                function (dataset) {

                    //var countries = topojson.feature(dataset, dataset.objects.ne_50m_admin_0_countries).features;
                    var districts = topojson.feature(dataset, dataset.objects.shapefile_m_nster_stadtteile).features;
                    console.log(districts);

                    var centroids = districts.map(function (feature) {
                        return geopath.centroid(feature);
                    });

                    d3.json("https://raw.githubusercontent.com/KathHv/Geodaten/master/opensensemap_org-arithmeticMean-Luftdruck-lat-lon-boxName-boxId-unit-20190121_172632.json")
                        .then(function (circlesdataset) {

                            console.log(circlesdataset);

                            var senseboxdataset = circlesdataset;
                            // data binding
                            var countryshapes = d3.select("svg").selectAll("path").data(districts);

                            // create paths
                            countryshapes.enter()
                                .append("path")
                                .attr("d", geopath)
                                .attr("class", "country")
                                .attr("fill", "red");

                            var circles = d3.select("svg").selectAll("circle").data(circlesdataset);
                            console.log(circles);

                            circles.enter()
                                .append("circle")
                                .attr("d", geopath)
                                .attr("class", "dot")
                                .attr("cx", function (d, i) {
                                    console.log("point " + d.lat + " , " + d.lon + " , " + d.boxName);
                                    return d.lat;
                                })
                                .attr("cy", function (d) {
                                    return d.lon;
                                })
                                .attr("transform", function (d) { // position the circle on the centroid of each polygon
                                    return "translate(" + currentprojection([d.lon, d.lat])+")";
                                })
                                .attr("r", 5)
                             .on("mouseover", function (d) {
                                    d3.select(this).classed("country hovered", true);
                                    div.style("display", "inline")
                                    div.text(d.boxName);
                                    // create bars for the current country, using the country code as parameter
                                    createLine(d.sensorId);

                                })
                                .on("mouseout", function (d) {

                                    d3.select(this).classed("country hovered", false);
                                    div.style("display", "none");
                                    // clear the content of the svg
                                    svg2.selectAll("*").remove();
                                    
                                });


                            function createLine(currentdistrictcode) {

                                console.log("Current sensor Id: " + currentdistrictcode);

                                var currentsensebox = new Object();
                                //  console.log(currentsensebox);
                                senseboxdataset.forEach(function (obj) {
    
                                    if (parseInt(obj.sensorId) == parseInt(currentdistrictcode)) {
                                        currentsensebox = obj;
                                    }

                                });

                                if (currentsensebox == undefined || currentsensebox == null || Object.keys(currentsensebox).length === 0) {
                                    console.log("No information available for this country");
                                    svg2.append("text").text("No information available for this country");
                                }
                                else {

                                    console.log(currentsensebox);

                                    // retrieve information about the current country
                                    var dataitem = formatObject(currentsensebox);
                                    //console.log(dataitem);
                                    var currentMinSensebox = d3.min(dataitem)[1];
                                    var currentMaxSensebox = d3.max(dataitem)[1];

                                    // creating scales and axes
                                    var xScale = d3.scaleTime()
                                        .domain([new Date(2019, 1, 17), new Date(2019, 1, 19)]) //, "1975", "2000", "2005", "2010"
                                        .range([0, width2]);

                                    var yScale = d3.scaleLinear()
                                        .domain([0, currentMaxSensebox])
                                        .range([height2, 0]);

                                    var xAxis = d3.axisBottom(xScale);

                                    var yAxis = d3.axisLeft(yScale)
                                        .tickValues([currentMaxSensebox / 4, currentMaxSensebox / 3, currentMaxSensebox / 2, currentMinSensebox]) // four values on the axis

                                    // add axes to the svg element
                                    svg2.append("g")
                                        .call(xAxis)
                                        .attr("transform", "translate (0, " + height2 + ")")

                                    svg2.append("g")
                                        .attr("class", "yAxis")
                                        .call(yAxis)
                                        .attr("transform", "translate (" + width2 + " , 0)");


                                    // create the line

                                    var line = d3.line()
                                        .x(function (d) { return xScale(d[0]); })
                                        .y(function (d) { return yScale(d[1]); });

                                    var lineGraph = svg2.append("path")
                                        .datum(dataitem)
                                        .attr("class", "line")
                                        .attr("stroke", "steelblue")
                                        .attr("stroke-width", 2)
                                        .attr("fill", "none")
                                        .attr("d", line)

                                    console.log(lineGraph);
                                }

                                // create circles for the measured values in the graph for a better visualization 
                                svg2.selectAll("circle")
                                    .data(dataitem)
                                    .enter().append("circle")
                                    .attr("class", "circle")
                                    .attr("cx", function (d) {
                                        console.log(d[0]);
                                        console.log(xScale(d[0]));
                                        return xScale(d[0]);
                                    })
                                    .attr("cy", function (d) { return yScale(d[1]); })
                                    .attr("fill", "#FFD700")
                                    .attr("r", 3);

                            }

                            // go through the whole data item for a country, and only keep the values from
                            var formatObject = function (rawdataobject) {
                                var formattedObject = new Array();

                                for (var key in rawdataobject) {
                                    // pick only values for some of the years
                                    if (key == "2019-01-18T09:00:00.000Z" || key == "2019-01-18T12:00:00.000Z" || key == "2019-01-18T10:00:00.000Z" || key == "2019-01-17T10:00:00.000Z" || 
                                        key == "2019-01-14T18:00:00.000Z" || key == "2019-01-15T10:00:00.000Z" || key == "2019-01-14T10:00:00.000Z" || key == "2019-01-13T10:00:00.000Z" ||
                                        key == "2019-01-14T19:00:00.000Z" || key == "2019-01-11T10:00:00.000Z" || key == "2019-01-10T10:00:00.000Z") {
                                        // remove spaces from the string, and convert it to Float
                                        //var value = parseFloat(rawdataobject[key].replace(/\s/g, ''));
                                        var temp = new Array(new Date(key), rawdataobject[key]);
                                        console.log(temp);
                                        formattedObject.push(temp);
                                    }
                                    else {
                                         continue;
                                    }


                                }
                                return formattedObject;
                            }




                        }),

                        function (error) {
                            console.log(error);

                        }
                    /*

                      // https://d3indepth.com/geographic/ [choice of right parameters for scaling]

                      // https://github.com/d3/d3-geo [path.centroid]

                      // DIV Formatting: https://stackoverflow.com/questions/8865458/vertically-center-text-with-css

                      // Bubble map ideas adapted from https://bl.ocks.org/mbostock/9943478

                      // Small entry on scaleSqrt() https://bl.ocks.org/d3indepth/775cf431e64b6718481c06fc45dc34f9

                      // d3 format: format numbers for human consumption https://github.com/d3/d3-format

                      // parts are adapted or edited from the Geovis Learnweb course.

                      */
                },


                function (error) {
                    console.log(error);
                }
            );


    </script>

</body>

</html>




